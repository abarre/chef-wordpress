backend default {
        .host = "<%= node['varnish']['backend_host'] %>";
        .port = "<%= node['varnish']['backend_port'] %>";
}

acl purge {
  "localhost";
  "127.0.0.1";
  "188.226.171.191";
}

# Block 2: Define a key based on the User-Agent which can be used for hashing.
# Also set the PS-CapabilityList header for PageSpeed server to respect.
sub generate_user_agent_based_key {
    # Define placeholder PS-CapabilityList header values for large and small
    # screens with no UA dependent optimizations. Note that these placeholder
    # values should not contain any of ll, ii, dj, jw or ws, since these
    # codes will end up representing optimizations to be supported for the
    # request.
    set req.http.default_ps_capability_list_for_large_screens = "LargeScreen.SkipUADependentOptimizations:";
    set req.http.default_ps_capability_list_for_small_screens = "TinyScreen.SkipUADependentOptimizations:";

    # As a fallback, the PS-CapabilityList header that is sent to the upstream
    # PageSpeed server should be for a large screen device with no browser
    # specific optimizations.
    set req.http.PS-CapabilityList = req.http.default_ps_capability_list_for_large_screens;

    # Cache-fragment 1: Desktop User-Agents that support lazyload_images (ll),
    # inline_images (ii) and defer_javascript (dj).
    # Note: Wget is added for testing purposes only.
    if (req.http.User-Agent ~ "(?i)Chrome/|Firefox/|MSIE |Safari|Wget") {
      set req.http.PS-CapabilityList = "ll,ii,dj:";
    }
    # Cache-fragment 2: Desktop User-Agents that support lazyload_images (ll),
    # inline_images (ii), defer_javascript (dj), webp (jw) and lossless_webp
    # (ws).
    if (req.http.User-Agent ~
        "(?i)Chrome/[2][3-9]+\.|Chrome/[[3-9][0-9]+\.|Chrome/[0-9]{3,}\.") {
      set req.http.PS-CapabilityList = "ll,ii,dj,jw,ws:";
    }
    # Cache-fragment 3: This fragment contains (a) Desktop User-Agents that
    # match fragments 1 or 2 but should not because they represent older
    # versions of certain browsers or bots and (b) Tablet User-Agents that
    # on all browsers and use image compression qualities applicable to large
    # screens. Note that even Tablets that are capable of supporting inline or
    # webp images, e.g. Android 4.1.2, will not get these advanced
    # optimizations.
    if (req.http.User-Agent ~ "(?i)Firefox/[1-2]\.|MSIE [5-8]\.|bot|Yahoo!|Ruby|RPT-HTTPClient|(Google \(\+https\:\/\/developers\.google\.com\/\+\/web\/snippet\/\))|Android|iPad|TouchPad|Silk-Accelerated|Kindle Fire") {
      set req.http.PS-CapabilityList = req.http.default_ps_capability_list_for_large_screens;
    }
    # Cache-fragment 4: Mobiles and small screen Tablets will use image compression
    # qualities applicable to small screens, but all other optimizations will be
    # those that work on all browsers.
    if (req.http.User-Agent ~ "(?i)Mozilla.*Android.*Mobile*|iPhone|BlackBerry|Opera Mobi|Opera Mini|SymbianOS|UP.Browser|J-PHONE|Profile/MIDP|portalmmm|DoCoMo|Obigo|Galaxy Nexus|GT-I9300|GT-N7100|HTC One|Nexus [4|7|S]|Xoom|XT907") {
      set req.http.PS-CapabilityList = req.http.default_ps_capability_list_for_small_screens;
    }
    # Remove placeholder header values.
    remove req.http.default_ps_capability_list_for_large_screens;
    remove req.http.default_ps_capability_list_for_large_screens;
}

sub vcl_recv {
  if (req.url ~ "\.pagespeed\.([a-z]\.)?[a-z]{2}\.[^.]{10}\.[^.]+") {
		# Skip the cache for .pagespeed. resource.  PageSpeed has its own
		# cache for these, and these could bloat up the caching layer.
		return (pass);
	}

	if (req.url == "/monit-check") {
    error 200 "Varnish up";
  }

 	if (req.restarts == 0) {
	  if (req.http.x-forwarded-for) {
	    set req.http.X-Forwarded-For =
	      req.http.X-Forwarded-For + ", " + client.ip;
	  } else {
	    set req.http.X-Forwarded-For = client.ip;
	  }
	}

	if (req.request == "PURGE") {
	  if(!client.ip ~ purge) {
	    error 405 "Not allowed.";
	  }

	  # No need to process further conditions; just purge the cache
	  return(lookup);
	}

	if (req.request != "GET" &&
	  req.request != "HEAD" &&
	  req.request != "PUT" &&
	  req.request != "POST" &&
	  req.request != "TRACE" &&
	  req.request != "OPTIONS" &&
	  req.request != "DELETE") {

	  /* Non-RFC2616 or CONNECT which is weird. */
	  return (pipe);
	}

	if (req.request != "GET" && req.request != "HEAD") {
	  /* We only deal with GET and HEAD by default */
	  return (pass);
	}

	if (!req.http.PS-CapabilityList) {
  		call generate_user_agent_based_key;
  	}

	# Normalize the "Accept-Encoding" headers
	if (req.http.Accept-Encoding) {
	  if (req.url ~ "\.(jpg|png|gif|gz|tgz|bz2|tbz|mp3|ogg)$") {
	    # No point in compressing these
	    remove req.http.Accept-Encoding;
	  } elsif (req.http.Accept-Encoding ~ "gzip") {
	    set req.http.Accept-Encoding = "gzip";
	  } elsif (req.http.Accept-Encoding ~ "deflate" && req.http.user-agent !~ "MSIE") {
	    set req.http.Accept-Encoding = "deflate";
	  } else {
	    # unkown algorithm
	    remove req.http.Accept-Encoding;
	  }
	}

	#  Pipe possibly large-sized objects; except sitemaps
	if (req.url ~ "^[^?]*\.(zip|tar|gz|tgz|bz2|mp[34]|pdf|rar|rtf|swf|wav)(\?.*)?$") {
	  if (req.url ~ "sitemap") { }
	  else {
	    return (pipe);
	  }
	}

	# Check the admin pages
	if (req.url ~ "wp-(login|admin/)" || req.url ~ "preview=true") {
	  return (pass);
	}

	# Check the cookies for wordpress-specific cookies
	if (req.http.cookie) {
		if (req.http.cookie ~ "(wp_|comment_)") {
		  return(pass);
		} else {
		  unset req.http.cookie;
		}
	}

	# Contact Pages
	if (req.url ~ "contact") {
	  return (pass);
	}

	#woocommerce
	if (req.url ~ "^/(panier|mon-compte|commande|addons)") {
	 return (pass);
	}

	if ( req.url ~ "\?add-to-cart=" ) {
	 return (pass);
	}

	# Images
	if (req.url ~ "\.(jpg|jpeg|png|gif|ico|tiff|tif|bmp|ppm|pgm|xcf|psd|webp|svg)") {
	  return (pass);
	}

	# CSS & JS
	if (req.url ~ "\.(css|js)") {
	  return (pass);
	}


	# HTML & text
	if (req.url ~ "\.(html?|txt)") {
	  return(pass);
	}


	# Fonts
	if (req.url ~ "\.(woff|eot|otf|ttf)") {
	  return (pass);
	}


	# Other static content
	if (req.url ~ "\.(zip|sql|tar|gz|bzip2)") {
	  return (pass);
	}

  # custom rules
  return (lookup);
}

sub vcl_hit {
    if (req.request == "PURGE") {
        purge;
        error 200 "Purged";
    }
    return (deliver);
}

sub vcl_miss {
    if (req.request == "PURGE") {
        purge;
        error 200 "Purged";
    }
    return (fetch);
}

sub vcl_fetch {

	### This file basically contains things that shouldn't be cached by Varnish after fetching from the backend

	# Admin pages
	if (req.url ~ "wp-(login|admin/)" || req.url ~ "preview=true") {
	  set beresp.http.X-Cacheable = "NO: User is logged-in!";
	  set beresp.http.Cache-Control = "max-age=0";
	  return (hit_for_pass);
	}

	#woocommerce
	if (req.url ~ "^/(panier|mon-compte|commande|addons)") {
	  set beresp.http.X-Cacheable = "NO: User has a cart";
	  set beresp.http.Cache-Control = "max-age=0";
	  return (hit_for_pass);
	}

	if ( req.url ~ "\?add-to-cart=" ) {
	  set beresp.http.X-Cacheable = "NO: User has a cart";
	  set beresp.http.Cache-Control = "max-age=0";
	  return (hit_for_pass);
	}

	# PHP
	if (req.url ~ "\.php$") {
	  set beresp.http.X-Cacheable = "NO: PHP!";
	  return (hit_for_pass);
	}

	# Contact Pages
	if (req.url ~ "contact") {
	  set beresp.http.X-Cacheable = "NO: Contact Page";
	  return (hit_for_pass);
	}


	# If backend response is NOT 200.
	if (beresp.status != 200 && beresp.status != 301) {
	  set beresp.http.Cache-Control = "max-age=0";
	  set beresp.http.X-Cacheable = "NO: Backup HTTP response is not 200";
	  return (hit_for_pass);
	}

  # Note #1 - Make sure, you have conf.d/receive/pagespeed.vcl in vcl_receive
	if (req.url ~ "\.pagespeed\.([a-z]\.)?[a-z]{2}\.[^.]{10}\.[^.]+") {
	  set beresp.http.X-Cacheable = "No: Pagespeed";
	  return (hit_for_pass);
	}

	# Images
	if (req.url ~ "\.(jpg|jpeg|png|gif|ico|tiff|tif|bmp|ppm|pgm|xcf|psd|webp|svg)") {
	  unset beresp.http.cookie;
	  set beresp.http.X-Cacheable = "NO: Images aren't cached";
	  return (hit_for_pass);
	}

	# CSS & JS
	if (req.url ~ "\.(css|js)") {
	  unset beresp.http.cookie;
	  set beresp.http.X-Cacheable = "NO: CSS & JS files aren't cached";
	  return (hit_for_pass);
	}

	# HTML & Text files
	if (req.url ~ "\.(html?|txt)") {
	  unset beresp.http.cookie;
	  set beresp.http.X-Cacheable = "NO: HTML & text files aren't cached";
	  return (hit_for_pass);
	}

	# Fonts
	if (req.url ~ "\.(woff|eot|otf|ttf)") {
	  unset beresp.http.cookie;
	  set beresp.http.X-Cacheable = "NO: Webfonts aren't cached";
	  return (hit_for_pass);
	}

	# Other static content
	if (req.url ~ "\.(zip|sql|tar|gz|bzip2|mp3|mp4|flv|ogg|swf)") {
	  unset beresp.http.cookie;
	  set beresp.http.X-Cacheable = "NO: Misc files aren't cached";
	  return (hit_for_pass);
	}

  # if a requests reaches this stage, then it is cacheable
  set beresp.http.X-Cacheable = "YES";

  # The default value of 120s can be modified here
  set beresp.ttl = 30d;

  return (deliver);
}

sub vcl_deliver {
  # Display the number of hits
  if (obj.hits > 0) {
    set resp.http.X-Cache = "HIT - " + obj.hits;
  } else {
    set resp.http.X-Cache = "MISS";
  }

	# Comment the following while doing maintenance
	unset resp.http.Server;
	unset resp.http.X-Varnish;
	unset resp.http.Via;
	unset resp.http.Age;
	unset resp.http.X-Cacheable;
	# unset resp.http.X-Cache;
	unset resp.http.X-Powered-By;
	unset resp.http.X-Page-Speed;

  return (deliver);
}

# The data on which the hashing will take place
sub vcl_hash {
  # Block 3: Use the PS-CapabilityList value for computing the hash.
  hash_data(req.http.PS-CapabilityList);
}